<p><html lang="en">
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Experiences with Numerics on OpenBSD - 8 - RNGs, again</title>
<link rel="stylesheet" href="w3.css" media="screen">
<link rel="canonical" href="https://j-bm.github.io/on/exp8.html">
</head>
<body></p>

<h1>Experiences with Numerics on OpenBSD - 8 - RNGs, again</h1>

<p>After the graphics/imagery work in the last experience, I thought to
review the definition of what &lsquo;quality&rsquo; meant for pseudo-random
number generators, again.</p>

<h2>Compare on different architectures:</h2>

<p>I added code for the xoroshiro128+ RNG, which uses various combinations
of xor, shift, and or operators to generate random numbers quickly.</p>

<p>On the Raspbery Pi4 running Raspian:</p>

<pre><code>$ ./xmcpi.x
xmcpi.f90 number of images:  1
approximating pi in   1 x   10100100100 points
  nsum    7932562674.0000000       msum    10100100100.000000
  pi   3.1415926535897931       iterated pi:    3.1415778439661208
  pi error   1.4809623672284999E-005
Elapsed wall clock time  278.     seconds, using  1 images.


pi@raspberrypi:~/rnums $ mpirun -np 2 -H localhost:4 ./xmcpi.x
xmcpi.f90 number of images:  2
approximating pi in   2 x   10100100100 points
  nsum    7932590015.0000000       msum    10100100100.000000
  nsum    7932562674.0000000       msum    10100100100.000000
  pi   3.1415926535897931       iterated pi:    3.1415832579718690
  pi error   9.3956179241239113E-006
Elapsed wall clock time  279.     seconds, using  2 images.

$ mpirun -np 4 -H localhost:4 ./xmcpi.x
xmcpi.f90 number of images:  4
approximating pi in   4 x   10100100100 points
  nsum    7932562674.0000000       msum    10100100100.000000
  nsum    7932637592.0000000       msum    10100100100.000000
  nsum    7932649267.0000000       msum    10100100100.000000
  nsum    7932590015.0000000       msum    10100100100.000000
  pi   3.1415926535897931       iterated pi:    3.1415965419986285
  pi error  -3.8884088353619006E-006
Elapsed wall clock time  403.     seconds, using  4 images.
</code></pre>

<p>The Rpi4 is overheating, and slows down, resulting in 400+ seconds
elapsed when running 4 cores at the same time.  However, the results are
exactly the same numerically as
for the Intel AMD64-compatible CPUs.</p>

<p>The xoroshiro128+ code is platform independent, with this very simple empirical test.</p>

<h3>TestU01</h3>

<p>So let&rsquo;s try a different test: the statistical tests frequently mentioned by
RNG practitioners (authors/users/critics).  This is the TestU01 suite
which includes a number of well-known RNGs and a scheme for testing anything
we might come up with.</p>

<p>The code is, roughly</p>

<pre><code>#include "unif01.h"
#include "bbattery.h"

#include "xoroshiro128plus_xd_xjr.h"
#include "xoroshiro128plus_xtc.h"
#include "pcg_od_ojr.h"

int main (void)
{
unif01_Gen *gen;

xoroshiro128plus_srandom(134893149852ull, 18324891485ull);
gen = unif01_CreateExternGen01 ("xoroshiro128plus_xd", xd_random_r8);
bbattery_SmallCrush (gen);
unif01_DeleteExternGen01 (gen);
...
</code></pre>

<p>Which is pretty dense code but basically runs the SmallCrush battery of tests on
the double-precision floating-point values generated by xoroshiro128plus_xd.</p>

<p>The test subjects are:</p>

<ul>
<li>xoroshiro128plus, and PCG RNG</li>
<li>the &ldquo;x-times-a-constant&rdquo; method</li>
<li>the &ldquo;jr&rdquo; [1.0,2.0) - 1.000 method</li>
<li>the &ldquo;d&rdquo; Downey scaled method</li>
</ul>


<h3>The Crush Tests</h3>

<p>The SmallCrush test is a shorter test suite, and all tests pass.</p>

<p>The Crush test is a longer test suite.
Of these, only 3 tests fail with unlikely p-values (outside 0.001 to 0.999):</p>

<ul>
<li>PCG with jr in the ClosePairs test (1 of 144)</li>
<li>PCG with &ldquo;d&rdquo; in the RandomWalk1 test (1 of 144)</li>
<li>xoroshiro128plus with &ldquo;d&rdquo; in the ClosePairs test (1 of 144)</li>
</ul>


<p>So, these RNGs are not so bad, accoring to TestU01.</p>

<h3>My Tests</h3>

<p>Looking at the binary (or hexadecimal) representation of the floating
point results, it&rsquo;s pretty clear there are issues with the [1,2)-1 and
the times-a-constant methods of creating floating-point numbers from
integer random numbers.</p>

<p>Some of the least significant bits are either always zero, or mostly zero.
For example, the frequency of bits in the &ldquo;xtc&rdquo; method gives</p>

<pre><code> bit nbr    actual  expected
bit    0   2522555   5050050
bit    1   3786768   5050050
bit    2   4416094   5050050
bit    3   4733053   5050050
bit    4   4893247   5050050
bit    5   4969861   5050050
</code></pre>

<p>and the &ldquo;xjr&rdquo; method gives</p>

<pre><code>bit    0         0   5050050
bit    1   2523599   5050050
bit    2   3785404   5050050
bit    3   4415926   5050050
bit    4   4734824   5050050
bit    5   4892002   5050050
</code></pre>

<p>meaning none of the lsbs are ever 1, and the next few bits are not one half
the time as they should be.  The number 5050050 is the expected number
of ones.</p>

<p>The &ldquo;good&rdquo; method by Downey looks like</p>

<pre><code>bit    0   5048674   5050050
bit    1   5048621   5050050
bit    2   5050834   5050050
bit    3   5048751   5050050
bit    4   5049737   5050050
bit    5   5049658   5050050
</code></pre>

<p>What is an objective, scientific method to measure this?  Chi-square, of course.
This test is for discrete distributions in large numbers.  Here we have
a mantissa of 23 bits (single-precision) or 53 bits
(double-precision) which should all
be independent and uniformly 1 or 0 half the time.  We&rsquo;ll run a Chi-square
test of the distribution of the 1-bits in these mantissas.</p>

<p>And for good measure I added a test of half-octet, meaning 4 bits, which
should always be averaging 7.5 in value.</p>

<p>The other measure is the frequency of exponents.  This should be exponential,
matching the concept that numbers &frac14; the size have an exponent &frac14; as likely.
For example</p>

<pre><code>Expon.   Freq.
...
-20        98
-19       167
-18       388
-17       753
-16      1480
...
 -4   6258023
 -3  12508379
 -2  25025356
 -1  50049539
</code></pre>

<p>This is easily tested by taking log2 of the frequency and checking that
log2(freq) is linear with the exponent.</p>

<p>(The above list of exponent frequencies is from od_random_r4 for 10G values.
The smaller exponents -31 through -21 have been omitted.)</p>

<h3>My test results</h3>

<p>Most of the single-precision methods work fine, since they essentially
are taking 64-bits (or 48 for the drand48 builtin) and using only 23 of
them.  Any issues with lsbs do not appear.</p>

<p>The acceptable methods for single-precision are the PCG and
xoroshiro128+ and ++  RNGs with
the Downey (d), jr (1-2]-1 method, and times-a-constant method.
These also pass the half-octet tests.</p>

<p>Not surprisingly, for double-precision, only the Downey (d) methods
pass the bits tests.  The xoroshiro+
passes the half-octets tests, while PCG only about a third of
the time. As the half-octet tests are biased
(some bits have more influence on the average value of a half-octet)
it&rsquo;s not clear to me this is really a useful test.</p>

<p>Here are some same results for 20 tests of PCG and xoroshiro128+ for 100M numbers:</p>

<pre><code>test    chisqure-bits   chisquare-halfoctets   Note

od_...r8   20 pass          9 of 20 pass       PCG
xd_...r8   20 pass          20 pass            xoroshiro128+
</code></pre>

<p>This contrasts with integer64 tests, where fewer of both PCG and xoroshiro128+
tests passed the halfoctet tests.  Rerunning those using the same seeds
results in:</p>

<pre><code>test    chisqure-bits   chisquare-halfoctets   Note

pcg        20 pass          6 of 20 pass       PCG
x...128+   20 pass          4 pass             xoroshiro128+
</code></pre>

<p>It is not surprising they differ; the floating point numbers are
processed from the random integers by shifts and sometimes replacement.</p>

<p>One variant to be considered is a cryptologic transformation of the random
result, before conversion to float, such as with AES128-CTR mode,
to see if that changes the result.  While slower, it is not better.</p>

<h3>Conclusion</h3>

<p>Statistical tests composed by statistical practitioners are not as complete as you
might hope.  Easy-to-check defects in RNGs are missed.  And this has been
true for <em>years</em>.</p>

<p>The practitioners have the wrong objectives in mind: generating statistics
not generating usable random numbers.</p>

<p>Do the least-significant-bits of pseudo-random floating-point numbers matter?  Especially
the double-precision kind?  Why, for some applications, yes they do.  When
taking differences, when making exact calculations locally and
averaging over large spatial areas (such as particle-in-cell
methods), when testing sensitivity of numerical models by masking (truncating
values), and so on.</p>

<p>April 2020<br>
Asahi Super Dry</p>

<p><br></p>

<p>Links:</p>

<p><a href="https://www.iro.umontreal.ca/~lecuyer/" title="Pierre L'Ecuyer website">Pierre L'Ecuyer website</a>
<br>
<a href="http://prng.di.unimi.it/" title="xoshiro / xoroshiro generators and the PRNG shootout">xoshiro / xoroshiro generators and the PRNG shootout</a>
<br></p>

<hr />

<p> <a href="exp1.html" title="OpenBSD Numerics Experience - 1 - RNG">OpenBSD Numerics Experience - 1 - RNG</a>
<br>
 <a href="exp2.html" title="OpenBSD Numerics Experience - 2 - RNG floats">OpenBSD Numerics Experience - 2 - RNG floats</a>
<br>
 <a href="exp3.html" title="OpenBSD Numerics Experience - 3 - FFTW">OpenBSD Numerics Experience - 3 - FFTW</a>
<br>
 <a href="exp4.html" title="OpenBSD Numerics Experience - 4 - CAF">OpenBSD Numerics Experience - 4 - CAF</a>
<br>
 <a href="exp5.html" title="OpenBSD Numerics Experience - 5 - MPI Networking">OpenBSD Numerics Experience - 5 - MPI Networking</a>
<br>
 <a href="exp6.html" title="OpenBSD Numerics Experience - 6 - Memory Models">OpenBSD Numerics Experience - 6 - Memory Models</a>
<br>
<a href="on.html" title="OpenBSD Numerics">OpenBSD Numerics</a>
<br>
 <a href="exp7.html" title="OpenBSD Numerics Experience - 7 - Python Image Display">OpenBSD Numerics Experience - 7 - Python Image Display</a>
<br>
 <a href="exp8.html" title="OpenBSD Numerics Experience - 8 - RNGs, again">OpenBSD Numerics Experience - 8 - RNGs, again</a>
<br>
 <a href="exp9.html" title="OpenBSD Numerics Experience - 9 - Nim">OpenBSD Numerics Experience - 9 - Nim</a>
<br>
 <a href="expa.html" title="OpenBSD Numerics Experience - A - Graphical Display">OpenBSD Numerics Experience - A - Graphical Display</a>
<br>
<a href="on.html" title="OpenBSD Numerics">OpenBSD Numerics</a>
<br></p>

<script data-goatcounter="https://93ff62b00d7de509ff88f53b.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>


<p></body></p>
